<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  
  <title>Observable &mdash; Monix</title>

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:image" content="https://monix.io/public/images/monix-logo-rect.png" />
  <meta name="twitter:site" content="@monix" />  
  <meta name="twitter:title" content="Observable &mdash; Monix" />
  <meta name="twitter:description" content="A data type for modeling and processing asynchronous and reactive streaming of events with non-blocking back-pressure." />

  <!-- Facebook Open-Graph -->
  <meta property="fb:app_id" content="2160100887367418" />
  <meta property="og:url" content="https://monix.io/docs/3x/reactive/observable" />
  <meta property="og:type" content="article" />
  <meta property="og:image" content="https://monix.io/public/images/monix-logo.png" />
  <meta property="og:image:secure_url" content="https://monix.io/public/images/monix-logo.png" />
  <meta property="og:title" content="Observable &mdash; Monix" />
  <meta property="og:description" content="A data type for modeling and processing asynchronous and reactive streaming of events with non-blocking back-pressure." />
  
  <!-- Javascript -->
  <script src="//code.jquery.com/jquery-2.2.4.min.js" type="text/javascript" language="javascript"></script>
  <script src="/public/js/toc.js?1569592993858105548" type="text/javascript" language="javascript"></script>
  <script src="/public/js/init.js?1569592993858105548" type="text/javascript" language="javascript"></script>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/all.css?1569592993858105548">
  <!--[if lt IE 9]>
  <link rel="stylesheet" href="/public/css/forkme.ie.css?1569592993858105548">
  <![endif]-->

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Web App Manifest, see: http://manifest.sysapps.org/ -->
  <link rel="manifest" href="/manifest.json">
  <!-- Icons -->
  <link rel="icon" sizes="48x48" href="/public/icons/icon-48x48.png">
  <link rel="icon" sizes="72x72" href="/public/icons/icon-72x72.png">
  <link rel="icon" sizes="96x96" href="/public/icons/icon-96x96.png">
  <link rel="icon" sizes="144x144" href="/public/icons/icon-144x144.png">
  <link rel="icon" sizes="192x192" href="/public/icons/icon-192x192.png">
  <link rel="icon" sizes="240x240" href="/public/icons/icon-240x240.png">
  <link rel="icon" sizes="384x384" href="/public/icons/icon-384x384.png">
  <!-- Mobile Safari / iOS Icons -->
  <link rel="apple-touch-icon" sizes="48x48" href="/public/icons/icon-48x48.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/public/icons/icon-72x72.png">
  <link rel="apple-touch-icon" sizes="96x96" href="/public/icons/icon-96x96.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/public/icons/icon-144x144.png">
  <link rel="apple-touch-icon" sizes="192x192" href="/public/icons/icon-192x192.png">
  <link rel="apple-touch-icon" sizes="240x240" href="/public/icons/icon-240x240.png">
  <link rel="apple-touch-icon" sizes="384x384" href="/public/icons/icon-384x384.png">
  <!-- Standard Favicon -->
  <link rel="shortcut icon" href="/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="Feed" href="/blog/atom.xml">
</head>


  <body class="monix layout">
    <div class="wrapper">
      <aside class="sidebar plus">
  <div class="container">
    <div class="sidebar-about">
      <a class="github-fork-ribbon left-top" href="https://github.com/monix/monix"
        title="Fork me on GitHub">Fork me on GitHub</a>

      <h1>
        <a href="/">
          <img src="/public/images/monix-logo.png"
            alt="Monix Logo" title="Monix" class="logo" />
        </a>
      </h1>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">About</a>
      <a class="sidebar-nav-item" href="/blog/">Blog</a>
      <a class="sidebar-nav-item active" href="/docs/3x/">Documentation</a>
      <a class="sidebar-nav-item" href="/presentations/">Presentations</a>
      <a class="sidebar-nav-item" href="/social.html">Follow @Monix</a>
      <a class="sidebar-nav-item" href="/privacy.html">Privacy Policy</a>
    </nav>
  </div>
</aside>


      <article class="content container">
        <div class="page">
  <h1 class="page-title">Observable</h1>
  <nav role="navigation" id="type-info">
    <a href="/api/3.0/monix/reactive/Observable.html">API Documentation</a>
    <a href="https://github.com/monix/monix/blob/v3.0.0/monix-reactive/shared/src/main/scala/monix/reactive/Observable.scala">Source Code</a>
    
    <a href="https://github.com/monix/monix.io/edit/master/_tut/docs/3x/reactive/observable.md">Edit Page</a>
  </nav>

  <nav role="navigation" id="toc"></nav>

  <h2 id="introduction">Introduction</h2>

<p>The <code class="highlighter-rouge">Observable</code> is a data type for modeling and processing
asynchronous and reactive streaming of events with non-blocking
back-pressure.</p>

<p>The <code class="highlighter-rouge">Observable</code> is strongly inspired by
<a href="http://reactivex.io/">ReactiveX</a>, but with an idiomatic Scala API and
influenced by the Scala ecosystem of projects such as
<a href="http://typelevel.org/cats/">Cats</a> and
<a href="http://scalaz.org/">Scalaz</a>. It’s also compatible with the
<a href="http://www.reactive-streams.org/">Reactive Streams</a> specification,
hence it has good interoperability.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We need a Scheduler in scope in order to make 
// the Observable produce elements when subscribed
</span><span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
<span class="k">import</span> <span class="nn">monix.reactive._</span>

<span class="k">import</span> <span class="nn">concurrent.duration._</span>

<span class="c1">// We first build an observable that emits a tick per second, 
// the series of elements being an auto-incremented long
</span><span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">interval</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
  <span class="c1">// Filtering out odd numbers, making it emit every 2 seconds
</span>  <span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
  <span class="c1">// We then make it emit the same element twice
</span>  <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nc">Observable</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span>
  <span class="c1">// This stream would be infinite, so we limit it to 10 items
</span>  <span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
  
<span class="c1">// Observables are lazy, nothing happens until you subscribe...
</span><span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span> <span class="n">source</span>
  <span class="c1">// On consuming it, we want to dump the contents to stdout
</span>  <span class="c1">// for debugging purposes
</span>  <span class="o">.</span><span class="py">dump</span><span class="o">(</span><span class="s">"O"</span><span class="o">)</span>
  <span class="c1">// Finally, start consuming it
</span>  <span class="o">.</span><span class="py">subscribe</span><span class="o">()</span>

</code></pre></div></div>

<p>At its simplest, <code class="highlighter-rouge">Observable</code> is a replacement for your regular
<a href="#scala.collection.Iterable">Iterable</a>
or Scala 
<a href="#scala.collection.immutable.Stream">Stream</a>, 
but with the ability to process asynchronous events without blocking. 
And in fact you can convert any <code class="highlighter-rouge">Iterable</code> into an <code class="highlighter-rouge">Observable</code>.</p>

<p>But <code class="highlighter-rouge">Observable</code> scales to complex problems, touching on
<em><a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">functional reactive programming (FRP)</a></em>,
or it can model complex interactions between producers and consumers,
being a potent alternative for
<a href="http://akka.io/">the actor model</a>.</p>

<h3 id="design-summary">Design Summary</h3>

<p>A visual representation of where it sits in the design space:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">Single</th>
      <th style="text-align: center">Multiple</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>Synchronous</strong></td>
      <td style="text-align: center">A</td>
      <td style="text-align: center">Iterable[A]</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>Asynchronous</strong></td>
      <td style="text-align: center">Future[A] / Task[A]</td>
      <td style="text-align: center">Observable[A]</td>
    </tr>
  </tbody>
</table>

<p>The Monix <code class="highlighter-rouge">Observable</code>:</p>

<ul>
  <li>models lazy &amp; asynchronous streaming of events</li>
  <li>it is highly composable and lawful</li>
  <li>it’s basically the
<a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer pattern</a>
on steroids</li>
  <li>you can also think of it as being like a Scala
<a href="#scala.concurrent.Future">Future</a> or like
a <a href="../eval/task.html">Task</a>, except with the ability to stream 
multiple items instead of just one, or you can think of it as an asynchronous 
and non-blocking
<a href="#scala.collection.Iterable">Iterable</a>
with benefits</li>
  <li>models producer-consumer relationships, where you can have a single
producer pushing data into one or multiple consumers</li>
  <li>works best for unidirectional communications</li>
  <li>allows fine-grained control over the <a href="../execution/scheduler.html#execution-model">execution model</a></li>
  <li>doesn’t trigger the execution, or any effects until <code class="highlighter-rouge">subscribe</code></li>
  <li>allows for cancelling of active streams</li>
  <li>never blocks any threads in its implementation</li>
  <li>does not expose any API calls that can block threads</li>
  <li>compatible with <a href="http://www.scala-js.org/">Scala.js</a> like the rest of Monix</li>
</ul>

<p>See <strong><a href="./observable-comparisons.html">comparisons with similar tools, like Akka or FS2</a></strong>.</p>

<h3 id="learning-resources">Learning resources</h3>

<p>The following documentation barely scratches a surface of <code class="highlighter-rouge">Observable</code> and is rather incomplete.
If you find it lacking, make sure to check either <a href="/api/3.0/monix/reactive/Observable.html">Observable API</a> or
comments <a href="https://github.com/monix/monix">in the code</a> directly. We put a lot of focus on scala docs.</p>

<p>Other great resource is a <a href="http://reactivex.io/">ReactiveX</a> documentation and everything about it which opens doors
to plenty of books, blog posts and Stack Overflow answers.
There are significant differences in the model but majority of functions behave the same so it is a fantastic source
of examples and additional explanations.</p>

<p>Last but not least, we are always happy to help on <a href="https://gitter.im/monix/monix">gitter channel</a>. Any feedback
regarding the documentation itself (like confusing wording) is really appreciated too.</p>

<h2 id="observable-contract">Observable Contract</h2>

<p><code class="highlighter-rouge">Observable</code> can be thought about as the next layer of abstraction in regard to <code class="highlighter-rouge">Observer</code> and <code class="highlighter-rouge">Subscriber</code>.</p>

<p>You could describe <code class="highlighter-rouge">Observable</code> in the following way:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Observable</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">subscribe</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">Observer</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Cancelable</span>
<span class="o">}</span>
</code></pre></div></div>

<p>where <code class="highlighter-rouge">Observer</code> is:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Observer</span><span class="o">[</span><span class="kt">-T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">onNext</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Ack</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">onError</span><span class="o">(</span><span class="n">ex</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>

  <span class="k">def</span> <span class="nf">onComplete</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Observer</code> subscribes to <code class="highlighter-rouge">Observable</code> so <code class="highlighter-rouge">Observable</code> internals need to respect <code class="highlighter-rouge">Observer</code> <a href="./observers.html#contract">contract</a> 
when they pass elements there. You can consider it being higher level interface which abstracts away details of the contract and handles it for the user.</p>

<h3 id="how-it-works-internally">How it works internally</h3>

<p>If it is your first contact with this type of stream it probably sounds confusing. The understanding of underlying model 
is not necessary to be successful user of <code class="highlighter-rouge">Observable</code>. If you would like to do it anyway (or perhaps contribute your own low level operators),
I will try to explain the essence of how it works. Note that implementations of many operators are filled with optimizations so they look much more
complicated than they really are.</p>

<p><code class="highlighter-rouge">Observable</code> will pass through the generated items to the <code class="highlighter-rouge">Observer</code>. It is done by calling <code class="highlighter-rouge">onNext</code>.
Imagine following situation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Observable</span><span class="o">.</span><span class="py">fromIterable</span><span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">3</span><span class="o">)</span>
  <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="o">)</span>
  <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="o">)</span>
  <span class="o">.</span><span class="py">sum</span>
  <span class="o">.</span><span class="py">firstL</span> <span class="c1">// returns Task[Long]
</span></code></pre></div></div>

<p><code class="highlighter-rouge">fromIterable</code> is a builder which creates an <code class="highlighter-rouge">Observable</code>. This is a place which implements <code class="highlighter-rouge">subscribe</code>. This method passes 
each element to its subscribers by calling <code class="highlighter-rouge">onNext</code>. Once the sequence is empty it calls <code class="highlighter-rouge">onComplete</code> to signal that there aren’t any 
elements left to process and entire <code class="highlighter-rouge">Observable</code> can end. 
Note that <code class="highlighter-rouge">observer.onNext(elem)</code> returns <code class="highlighter-rouge">Future[Ack]</code>. To obey the contract and preserve backpressure, we have to wait for its result before 
we pass the next element. <code class="highlighter-rouge">Ack</code> can be either <code class="highlighter-rouge">Continue</code> (ok to send next element) or <code class="highlighter-rouge">Stop</code> (we should shut down).
It means we have a way to stop downstream (by calling <code class="highlighter-rouge">onComplete</code>) and an upstream (returning <code class="highlighter-rouge">Stop</code> after <code class="highlighter-rouge">onNext</code>).</p>

<p><code class="highlighter-rouge">map</code> is essentially <code class="highlighter-rouge">Observer =&gt; Observer</code> function. It implements <code class="highlighter-rouge">onNext</code>, <code class="highlighter-rouge">onError</code> and <code class="highlighter-rouge">onComplete</code>.
 The happy path goes like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(1) fromIterable calls map1.onNext(i)
(2) map1 does transformation and calls map2.onNext(i + 2)
(3) map2 does transformation and calls sumL.onNext(i * 3)
(4) sum  saves and acknowledges incoming items and does not call firstL.onNext until it receives onComplete
(5) firstL waits for the first onNext to complete a Task
</code></pre></div></div>

<p>Points (1) to (3) go in loop until the entire sequence of numbers is consumed. 
When <code class="highlighter-rouge">sum</code> acknowledges (returns from <code class="highlighter-rouge">onNext</code> method) to <code class="highlighter-rouge">map2</code>, <code class="highlighter-rouge">map2</code> can acknowledge to <code class="highlighter-rouge">map1</code> which in turn
acknowledges to <code class="highlighter-rouge">fromIterable</code> and a new item can be sent. 
In case any <code class="highlighter-rouge">onNext</code> returns a <code class="highlighter-rouge">Stop</code>, it would also propagate upstream and there wouldn’t be any new items generated.</p>

<p>Now if you jump into the source code of operators, you will see that they are obfuscated by concurrency, error handling
and lots of optimizations but the essence of the model works as described above. There is nothing more to it, no extra
interpreters or materializers to add an extra layer of indirection so if this section makes sense to you, you should have
a decent idea of what’s going on “behind the scenes”.</p>

<h2 id="observable-and-functional-programming">Observable and Functional Programming</h2>

<p><code class="highlighter-rouge">Observable</code> internals are written in imperative, Java-like style. It doesn’t look pretty and can be discouraging
if you’re trying to write your own operator but together with relatively simple model (in terms of operations to do) it
buys a lot of performance and is a big reason why it does so well <a href="https://github.com/monix/streaming-benchmarks">in comparison to competition</a>.</p>

<p>However, <code class="highlighter-rouge">Observable</code> exposes a vast number of purely functional operators that compose very well and you can build on top of them in
similar way to how it’s done in other streaming libraries from FP ecosystem.</p>

<p>If you’re mostly using available methods and want to write purely functional application then you’re in luck because
dirty internals don’t leak outside and majority of API is pure and the process of constructing and executing <code class="highlighter-rouge">Observable</code> is also pure.</p>

<p>The main drawback in comparison to purely functional streams, such as <a href="https://github.com/functional-streams-for-scala/fs2">fs2</a> or
<a href="/api/3.0/monix/tail/Iterant.html">Iterant</a> is availability of impure functions in API so if you have inexperienced 
team members, they could be tempted to use them. Fortunately, all of them are marked with <code class="highlighter-rouge">@UnsafeBecauseImpure</code> annotation and explained in ScalaDoc. 
There should always be a referentially transparent replacement to solve your use case but if your team is not fully committed to FP, these functions can be very useful.</p>

<p>For instance, convenient way to share <code class="highlighter-rouge">Observable</code> is using <code class="highlighter-rouge">Hot Observable</code> but it’s not referentially transparent.
Nevertheless, you could do the same thing using <code class="highlighter-rouge">doOnNext</code> or <code class="highlighter-rouge">doOnNextF</code> and purely functional concurrency structures from <code class="highlighter-rouge">Cats-Effect</code> such as <code class="highlighter-rouge">Ref</code> or <code class="highlighter-rouge">MVar</code> to share state in more controlled manner.</p>

<p>Decision is up to the user to choose what’s better for them and their team.</p>

<h2 id="execution">Execution</h2>

<p>When you create <code class="highlighter-rouge">Observable</code> nothing actually happens until you call <code class="highlighter-rouge">subscribe</code>. 
It means that (apart from impure parts of API) <code class="highlighter-rouge">Observable</code> preserves referential transparency.</p>

<p><code class="highlighter-rouge">Subscribe</code> is considered low-level operator and it is advised not to use it unless you know exactly what you are doing. 
You can think about it as <code class="highlighter-rouge">unsafePerformIO</code>.</p>

<p>Preferred way to deal with <code class="highlighter-rouge">Observable</code> is to convert it to <a href="./../eval/task.html">Task</a> and compose it all the way
through your program until the very end (Main method).</p>

<p>Two main ways to convert <code class="highlighter-rouge">Observable</code> to <code class="highlighter-rouge">Task</code> are described below.</p>

<h3 id="consumer">Consumer</h3>

<p>One of the ways to trigger <code class="highlighter-rouge">Observable</code> is to use <a href="./consumer.html">Consumer</a> which can be described as a function that converts <code class="highlighter-rouge">Observable</code> into <code class="highlighter-rouge">Task</code>.</p>

<p>You can either create your own <code class="highlighter-rouge">Consumer</code> or use one of many prebuilt ones:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">list</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> 
    <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1000</span><span class="o">)</span>
      <span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
      <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
      
<span class="k">val</span> <span class="nv">consumer</span><span class="k">:</span> <span class="kt">Consumer</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">Consumer</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="mi">0L</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
    
<span class="k">val</span> <span class="nv">task</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">list</span><span class="o">.</span><span class="py">consumeWith</span><span class="o">(</span><span class="n">consumer</span><span class="o">)</span>
</code></pre></div></div>

<p>You can find more examples in <a href="./consumer.html">Consumer documentation</a>.</p>

<h3 id="foldleft-methods">FoldLeft Methods</h3>

<p>Any method suffixed with <code class="highlighter-rouge">L</code> in <code class="highlighter-rouge">Observable</code> API converts it into <code class="highlighter-rouge">Task</code>.</p>

<p>For example you can use <code class="highlighter-rouge">firstL</code> to obtain the first element of the <code class="highlighter-rouge">Observable</code>:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Task(0)
</span><span class="k">val</span> <span class="nv">task</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1000</span><span class="o">).</span><span class="py">firstL</span>
</code></pre></div></div>

<p>Equivalent to the <code class="highlighter-rouge">Task</code> described in previous section would be:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">list</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> 
    <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1000</span><span class="o">)</span>
      <span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
      <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
       
<span class="k">val</span> <span class="nv">task</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">list</span><span class="o">.</span><span class="py">foldLeftL</span><span class="o">(</span><span class="mi">0L</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>
<h2 id="building-observable">Building Observable</h2>

<p>You can find them in <code class="highlighter-rouge">Observable</code> companion object. Below are several examples:</p>

<h3 id="observablepure-now">Observable.pure (now)</h3>

<p><code class="highlighter-rouge">Observable.pure</code> (alias for <code class="highlighter-rouge">now</code>) simply lifts an already known 
value in the <code class="highlighter-rouge">Observable</code> context.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">obs</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">now</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="c1">//=&gt; Effect
// obs: monix.reactive.Observable[String] = NowObservable@327a283b
</span></code></pre></div></div>

<h3 id="observabledelay-eval">Observable.delay (eval)</h3>

<p><code class="highlighter-rouge">Observable.delay</code> (alias for <code class="highlighter-rouge">eval</code>) lifts non-strict
value in the <code class="highlighter-rouge">Observable</code>. It is evaluated upon subscription.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">obs</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">delay</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="c1">// obs: monix.reactive.Observable[String] = EvalAlwaysObservable@48a8050
</span><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">obs</span><span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">// task: monix.eval.Task[Unit] = Task.Async$1782722529
</span>
<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span>
<span class="c1">//=&gt; Effect
//=&gt; Hello!
</span>
<span class="c1">// The evaluation (and thus all contained side effects)
// gets triggered on each runToFuture:
</span><span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span>
<span class="c1">//=&gt; Effect
//=&gt; Hello!
</span></code></pre></div></div>

<h3 id="observableevalonce">Observable.evalOnce</h3>

<p><code class="highlighter-rouge">Observable.evalOnce</code> takes a non-strict value and converts it into an Observable
that emits a single element and that memoizes the value for subsequent invocations.
It also has guaranteed idempotency and thread-safety:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">obs</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">evalOnce</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="c1">// obs: monix.reactive.Observable[String] = EvalOnceObservable@3233e694
</span><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">obs</span><span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">// task: monix.eval.Task[Unit] = Task.Async$1782722529
</span>
<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span>
<span class="c1">//=&gt; Effect
//=&gt; Hello!
</span>
<span class="c1">// Result was memoized on the first run!
</span><span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!
</span></code></pre></div></div>

<h3 id="observablefromiterable">Observable.fromIterable</h3>

<p><code class="highlighter-rouge">Observable.fromIterable</code> converts any <code class="highlighter-rouge">Iterable</code> into <code class="highlighter-rouge">Observable</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">obs</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">fromIterable</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="c1">// obs: monix.reactive.Observable[Int] = IterableAsObservable@7b0e123d
</span>
<span class="nv">obs</span><span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">).</span><span class="py">runToFuture</span>
<span class="c1">//=&gt; 1
//=&gt; 2
//=&gt; 3
</span></code></pre></div></div>

<h3 id="observablesuspend-defer">Observable.suspend (defer)</h3>

<p><code class="highlighter-rouge">Observable.suspend</code> (alias for defer) allows suspending side effects:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>
<span class="k">import</span> <span class="nn">scala.io.Source</span>

<span class="k">def</span> <span class="nf">readFile</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> 
    <span class="nv">Observable</span><span class="o">.</span><span class="py">suspend</span> <span class="o">{</span>
        <span class="c1">// The side effect won't happen until subscription
</span>        <span class="k">val</span> <span class="nv">lines</span> <span class="k">=</span> <span class="nv">Source</span><span class="o">.</span><span class="py">fromFile</span><span class="o">(</span><span class="n">path</span><span class="o">).</span><span class="py">getLines</span>
        <span class="nv">Observable</span><span class="o">.</span><span class="py">fromIterator</span><span class="o">(</span><span class="nc">Task</span><span class="o">(</span><span class="n">lines</span><span class="o">))</span>
    <span class="o">}</span>
</code></pre></div></div>

<h3 id="observableraiseerror">Observable.raiseError</h3>

<p><code class="highlighter-rouge">Observable.raiseError</code> constructs an Observable that calls <code class="highlighter-rouge">onError</code> on any subscriber emitting specified <code class="highlighter-rouge">Exception</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"my exception"</span><span class="o">))</span>
<span class="c1">// observable: monix.reactive.Observable[Int]
</span>
<span class="o">{</span>
<span class="n">observable</span>
  <span class="o">.</span><span class="py">onErrorHandle</span> <span class="o">{</span><span class="n">ex</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Got exception: ${ex.getMessage}"</span><span class="o">);</span> <span class="mi">1</span><span class="o">}</span>
  <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">//=&gt; Got exception: my exception
//=&gt; 1
</span></code></pre></div></div>

<h2 id="sending-elements-to-observable">Sending elements to Observable</h2>

<p>There are several options to feed <code class="highlighter-rouge">Observable</code> with elements from other part of the application.</p>

<h3 id="concurrentqueue">ConcurrentQueue</h3>

<p><code class="highlighter-rouge">monix-catnap</code> module provides <a href="https://monix.io/api/3.0/monix/catnap/ConcurrentQueue.html">ConcurrentQueue</a> that can be used
with <code class="highlighter-rouge">Observable.repeatEvalF</code> builder to create <code class="highlighter-rouge">Observable</code> from it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.catnap.ConcurrentQueue</span>
<span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>

<span class="k">def</span> <span class="nf">feedItem</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">queue</span><span class="k">:</span> <span class="kt">ConcurrentQueue</span><span class="o">[</span><span class="kt">Task</span>, <span class="kt">A</span><span class="o">],</span> <span class="n">item</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">queue</span><span class="o">.</span><span class="py">offer</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">processStream</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">observable</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">observable</span>
    <span class="o">.</span><span class="py">mapParallelUnordered</span><span class="o">(</span><span class="mi">3</span><span class="o">)(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">completedL</span>
<span class="o">}</span>

<span class="o">{</span>
  <span class="nv">ConcurrentQueue</span><span class="o">.</span><span class="py">unbounded</span><span class="o">[</span><span class="kt">Task</span>, <span class="kt">Int</span><span class="o">]().</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">queue</span> <span class="k">=&gt;</span>
    <span class="nc">Task</span>
      <span class="o">.</span><span class="py">parZip2</span><span class="o">(</span>
        <span class="nf">feedItem</span><span class="o">(</span><span class="n">queue</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
        <span class="nf">processStream</span><span class="o">(</span><span class="nv">Observable</span><span class="o">.</span><span class="py">repeatEvalF</span><span class="o">(</span><span class="nv">queue</span><span class="o">.</span><span class="py">poll</span><span class="o">))</span>
      <span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If you’re curious why we have to <code class="highlighter-rouge">flatMap</code> <a href="https://vimeo.com/294736344">see excellent presentation by Fabio Labella</a>.
Note that you can also create <code class="highlighter-rouge">Observable</code> from other tools for Concurrency, such as <code class="highlighter-rouge">MVar</code> or <code class="highlighter-rouge">Deferred</code>.</p>

<h3 id="concurrentsubject">ConcurrentSubject</h3>

<p>If you’re not afraid to get your hands dirty, then you can use <code class="highlighter-rouge">ConcurrentSubject</code> to get equivalent functionality:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.Ack</span>
<span class="k">import</span> <span class="nn">monix.reactive.subjects.ConcurrentSubject</span>
<span class="k">import</span> <span class="nn">monix.reactive.</span><span class="o">{</span><span class="nc">MulticastStrategy</span><span class="o">,</span> <span class="nc">Observable</span><span class="o">,</span> <span class="nc">Observer</span><span class="o">}</span>

<span class="k">val</span> <span class="nv">subject</span><span class="k">:</span> <span class="kt">ConcurrentSubject</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">ConcurrentSubject</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nv">MulticastStrategy</span><span class="o">.</span><span class="py">replay</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">feedItem</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">observer</span><span class="k">:</span> <span class="kt">Observer</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">item</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Ack</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">deferFuture</span><span class="o">(</span><span class="nv">observer</span><span class="o">.</span><span class="py">onNext</span><span class="o">(</span><span class="n">item</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">processStream</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">observable</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">observable</span>
    <span class="o">.</span><span class="py">mapParallelUnordered</span><span class="o">(</span><span class="mi">3</span><span class="o">)(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">completedL</span>
<span class="o">}</span>

<span class="o">{</span>
<span class="nc">Task</span>
  <span class="o">.</span><span class="py">parZip2</span><span class="o">(</span>
    <span class="nf">feedItem</span><span class="o">(</span><span class="n">subject</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
    <span class="nf">processStream</span><span class="o">(</span><span class="n">subject</span><span class="o">)</span>
  <span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In this case we transformed <code class="highlighter-rouge">Future</code> to <code class="highlighter-rouge">Task</code> so the example is pure (other than not suspending <code class="highlighter-rouge">ConcurrentSubject</code> creation) but you
don’t have to do that if you prefer staying with <code class="highlighter-rouge">Future</code>.</p>

<p><a href="#subjects">More on Subjects later.</a></p>

<h2 id="mapping-observable">Mapping Observable</h2>

<h3 id="map">map</h3>

<p><code class="highlighter-rouge">Observable#map</code> applies a function <code class="highlighter-rouge">f</code> to all elements in the source stream.</p>

<p><img src="/public/images/marbles/map.png" align="center" style="max-width: 100%" /></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Scheduler</span>
<span class="k">import</span> <span class="nn">monix.execution.exceptions.DummyException</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>

<span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span> 
  <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
    <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">el</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"new elem: $el"</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">stream</span><span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">).</span><span class="py">runToFuture</span>

<span class="c1">// new elem: 1
// new elem: 2
// new elem: 3
// new elem: 4
</span></code></pre></div></div>

<p>Prefer to use functions that are total because any exception will terminate the stream (see <a href="#errorHandling">Error Handling</a> section) :</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">failed</span> <span class="k">=</span> <span class="o">{</span> 
  <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
    <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="nc">DummyException</span><span class="o">(</span><span class="s">"avoid it!"</span><span class="o">))</span>
<span class="o">}</span>

<span class="nv">failed</span><span class="o">.</span><span class="py">subscribe</span><span class="o">()</span>

<span class="c1">// monix.execution.exceptions.DummyException: avoid it!
//	at MapObservable$.$anonfun$failedStream$1(MapObservable.scala:14)
//	at MapObservable$.$anonfun$failedStream$1$adapted(MapObservable.scala:14)
//	at monix.reactive.internal.operators.MapOperator$$anon$1.onNext(MapOperator.scala:41)
</span></code></pre></div></div>

<h3 id="mapeval">mapEval</h3>

<p><code class="highlighter-rouge">Observable#mapEval</code> is similar to <code class="highlighter-rouge">map</code> but it takes <code class="highlighter-rouge">f: A =&gt; Task[B]</code> which represents a function with effectful result that can produce at most one value.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">).</span><span class="py">mapEval</span><span class="o">(</span><span class="n">l</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">evalAsync</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$l: run asynchronously"</span><span class="o">)))</span>

<span class="nv">stream</span><span class="o">.</span><span class="py">subscribe</span><span class="o">()</span>

<span class="c1">// 1: run asynchronously
// 2: run asynchronously
// 3: run asynchronously
// 4: run asynchronously
</span></code></pre></div></div>

<p>There is also a <code class="highlighter-rouge">mapEvalF</code> variant for other types which can be converted to <code class="highlighter-rouge">Task</code>, i.e. <code class="highlighter-rouge">Future</code>, <code class="highlighter-rouge">cats.effect.IO</code>, <code class="highlighter-rouge">ZIO</code> etc.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.Future</span>

<span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">).</span><span class="py">mapEvalF</span><span class="o">(</span><span class="n">l</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$l: run asynchronously"</span><span class="o">)))</span>

<span class="nv">stream</span><span class="o">.</span><span class="py">subscribe</span><span class="o">()</span>

<span class="c1">// 1: run asynchronously
// 2: run asynchronously
// 3: run asynchronously
// 4: run asynchronously
</span></code></pre></div></div>

<h3 id="mapparallel">mapParallel</h3>

<p><code class="highlighter-rouge">mapEval</code> can process elements asynchronously but it does it one-by-one. 
In case we would like to run <code class="highlighter-rouge">n</code> tasks in parallel, we can use either <code class="highlighter-rouge">mapParallelOrdered</code> or <code class="highlighter-rouge">mapParallelUnordered</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span>
    <span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
    <span class="o">.</span><span class="py">mapParallelOrdered</span><span class="o">(</span><span class="n">parallelism</span> <span class="k">=</span> <span class="mi">2</span><span class="o">)(</span><span class="n">i</span> <span class="k">=&gt;</span>
      <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i: start asynchronously"</span><span class="o">))</span>
        <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nv">Task</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">4.</span><span class="n">second</span><span class="o">)</span> <span class="k">else</span> <span class="nv">Task</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">))</span>
        <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">i</span><span class="o">)</span>
    <span class="o">).</span><span class="py">foreachL</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i: done"</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">// 2: start asynchronously
// 1: start asynchronously
// 1: done
// 3: start asynchronously
// 2: done
// 3: done
// 4: start asynchronously
// 4: done
</span></code></pre></div></div>

<p>The order of execution of <code class="highlighter-rouge">Tasks</code> inside <code class="highlighter-rouge">mapParallelOrdered</code> is nondeterministic but they will be always passed to the downstream in the FIFO order, i.e. all <code class="highlighter-rouge">done</code> prints will have increasing indices in this example.
In case we don’t need this guarantee, we can use <code class="highlighter-rouge">mapParallelUnordered</code> which is faster. The code above would result in the following output:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2: start asynchronously
1: start asynchronously
1: done
3: start asynchronously
3: done
4: start asynchronously
2: done
4: done
</code></pre></div></div>

<h3 id="flatmap-concatmap">flatMap (concatMap)</h3>

<p><code class="highlighter-rouge">Observable#flatMap</code> (aliased to <code class="highlighter-rouge">concatMap</code>) applies a function which returns an <code class="highlighter-rouge">Observable</code>. 
For each input element, the resulting <code class="highlighter-rouge">Observable</code> is processed before the next input element.</p>

<p><img src="/public/images/marbles/flat-map.png" align="center" style="max-width: 100%" /></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
    <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Observable</span><span class="o">(</span><span class="n">s</span><span class="s">"${i}A"</span><span class="o">,</span> <span class="n">s</span><span class="s">"${i}B"</span><span class="o">))</span>
    <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// 2A
// 2B
// 3A
// 3B
// 4A
// 4B
</span></code></pre></div></div>

<p>Note that if a function returns an infinite <code class="highlighter-rouge">Observable</code>, it will never process the next elements from the source:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
    <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">never</span> <span class="k">else</span> <span class="nc">Observable</span><span class="o">(</span><span class="n">s</span><span class="s">"${i}A"</span><span class="o">,</span> <span class="n">s</span><span class="s">"${i}B"</span><span class="o">))</span>
    <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Nothing is printed
</span></code></pre></div></div>

<h3 id="mergemap">mergeMap</h3>

<p><code class="highlighter-rouge">Observable#mergeMap</code> also takes a function which can return an <code class="highlighter-rouge">Observable</code> but it can process the source <em>concurrently</em>. It doesn’t backpressure on elements
from the source and subscribes to all of the <code class="highlighter-rouge">Observable</code> produced from the source until they terminate. These produced <code class="highlighter-rouge">Observable</code> are often called <em>inner</em> or <em>child</em>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">++</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">50.</span><span class="n">millis</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">source</span>
    <span class="o">.</span><span class="py">mergeMap</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Observable</span><span class="o">(</span><span class="n">s</span><span class="s">"${i}A"</span><span class="o">,</span> <span class="n">s</span><span class="s">"${i}B"</span><span class="o">).</span><span class="py">delayOnNext</span><span class="o">(</span><span class="mf">50.</span><span class="n">millis</span><span class="o">))</span>
    <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The possible result of the snippet above is depicted in the following picture:</p>

<p><img src="/public/images/marbles/merge-map.png" align="center" style="max-width: 100%" /></p>

<p>Since the inner <code class="highlighter-rouge">Observables</code> are executed concurrently, we can also return an <code class="highlighter-rouge">Observable</code> which takes a very long time or does not terminate at all without slowing down the entire stream.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
    <span class="o">.</span><span class="py">mergeMap</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">never</span> <span class="k">else</span> <span class="nc">Observable</span><span class="o">(</span><span class="n">s</span><span class="s">"${i}A"</span><span class="o">,</span> <span class="n">s</span><span class="s">"${i}B"</span><span class="o">))</span>
    <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// 3A
// 3B
// 4A
// 4B
</span></code></pre></div></div>

<p>Keep in mind that <code class="highlighter-rouge">mergeMap</code> keeps all active subscription so it is possible to end up with a memory leak if we forget to close infinite <code class="highlighter-rouge">Observable</code>.
In case one of the <code class="highlighter-rouge">Observable</code> returns an error, other active streams will be canceled and resulting <code class="highlighter-rouge">Observable</code> will return the original error:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
    <span class="o">.</span><span class="py">mergeMap</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span>
      <span class="nf">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="nc">DummyException</span><span class="o">(</span><span class="s">"fail"</span><span class="o">))</span>
      <span class="k">else</span> <span class="nc">Observable</span><span class="o">(</span><span class="n">s</span><span class="s">"${i}A"</span><span class="o">,</span> <span class="n">s</span><span class="s">"${i}B"</span><span class="o">).</span><span class="py">doOnSubscriptionCancel</span><span class="o">(</span><span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i: cancelled"</span><span class="o">)))</span>
    <span class="o">)</span>
    <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// 2A
// 2B
// 4: cancelled
// Exception in thread "main" monix.execution.exceptions.DummyException: fail
</span></code></pre></div></div>

<h3 id="switchmap">switchMap</h3>
<p>Similarly to <code class="highlighter-rouge">mergeMap</code>, <code class="highlighter-rouge">Observable#switchMap</code> does not backpressure on elements from the source stream but it <em>switches</em> to the first <code class="highlighter-rouge">Observable</code> returned by the provided function that will produce an element. Then it cancels the other inner streams so there is only one active subscription at the time. It makes it safer than <code class="highlighter-rouge">mergeMap</code> because there is no danger of memory leak but it interrupts ongoing requests if something new arrives.</p>

<p><img src="/public/images/marbles/switch-map.png" align="center" style="max-width: 100%" /></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.ExitCase</span>

<span class="k">def</span> <span class="nf">child</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="n">s</span><span class="s">"${i}A"</span><span class="o">,</span> <span class="n">s</span><span class="s">"${i}B"</span><span class="o">,</span> <span class="n">s</span><span class="s">"${i}C"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">delayOnNext</span><span class="o">(</span><span class="mf">50.</span><span class="n">millis</span><span class="o">)</span>
    <span class="o">.</span><span class="py">guaranteeCase</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nv">ExitCase</span><span class="o">.</span><span class="py">Completed</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i: Request has been completed."</span><span class="o">))</span>
      <span class="k">case</span> <span class="nv">ExitCase</span><span class="o">.</span><span class="py">Error</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i: Request has encountered an error."</span><span class="o">))</span>
      <span class="k">case</span> <span class="nv">ExitCase</span><span class="o">.</span><span class="py">Canceled</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i: Request has been canceled."</span><span class="o">))</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
    <span class="o">.</span><span class="py">delayOnNext</span><span class="o">(</span><span class="mf">100.</span><span class="n">millis</span><span class="o">)</span>
    <span class="o">.</span><span class="py">switchMap</span><span class="o">(</span><span class="n">child</span><span class="o">)</span>
    <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// 2A
// 2: Request has been canceled.
// 3A
// 3B
// 3: Request has been canceled.
// 4A
// 4B
// 4C
// 4: Request has been completed.
</span></code></pre></div></div>

<h3 id="summary">Summary</h3>

<p>If you want to backpressure source <code class="highlighter-rouge">Observable</code> when emitting new events, use:</p>
<ul>
  <li><code class="highlighter-rouge">map</code> for pure, synchronous functions which return only one value</li>
  <li><code class="highlighter-rouge">mapEval</code> or <code class="highlighter-rouge">mapParallel</code> for effectful, possibly asynchronous functions which return up to one value</li>
  <li><code class="highlighter-rouge">flatMap</code> for effectful, possibly asynchronous functions which return a stream of values</li>
</ul>

<p>If you want to process source <code class="highlighter-rouge">Observable</code> concurrently, use:</p>
<ul>
  <li><code class="highlighter-rouge">mergeMap</code> if you want to process all inner streams</li>
  <li><code class="highlighter-rouge">switchMap</code> if you want to keep only the most recent inner stream</li>
</ul>

<h2 id="scheduling">Scheduling</h2>

<p><code class="highlighter-rouge">Observable</code> is a great fit not only for streaming data but also for control flow such as scheduling. 
It provides several builders for this purpose and it’s easy to combine it with <code class="highlighter-rouge">Task</code> if all you want is to
run a <code class="highlighter-rouge">Task</code> in specific intervals.</p>

<h3 id="intervalwithfixeddelay-interval">intervalWithFixedDelay (interval)</h3>

<p><code class="highlighter-rouge">Observable.intervalWithFixedDelay</code> takes a <code class="highlighter-rouge">delay</code> and an optional <code class="highlighter-rouge">initialDelay</code>. It creates an <code class="highlighter-rouge">Observable</code> that
emits auto-incremented natural numbers (longs) spaced by a given time interval. Starts from 0 with <code class="highlighter-rouge">initialDelay</code> (or immediately), 
after which it emits incremented numbers spaced by the <code class="highlighter-rouge">delay</code> of time. The given <code class="highlighter-rouge">delay</code> of time acts as a fixed 
delay between successive events.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.schedulers.TestScheduler</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>

<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="c1">// using `TestScheduler` to manipulate time
</span><span class="k">implicit</span> <span class="k">val</span> <span class="nv">sc</span> <span class="k">=</span> <span class="nc">TestScheduler</span><span class="o">()</span>

<span class="k">val</span> <span class="nv">stream</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span>
    <span class="o">.</span><span class="py">intervalWithFixedDelay</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span>
    <span class="o">.</span><span class="py">mapEval</span><span class="o">(</span><span class="n">l</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">l</span><span class="o">))</span>
    <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">stream</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">(</span><span class="n">sc</span><span class="o">)</span>

<span class="nv">sc</span><span class="o">.</span><span class="py">tick</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span> <span class="c1">// prints 0
</span><span class="nv">sc</span><span class="o">.</span><span class="py">tick</span><span class="o">(</span><span class="mf">4.</span><span class="n">second</span><span class="o">)</span> <span class="c1">// prints 1
</span><span class="nv">sc</span><span class="o">.</span><span class="py">tick</span><span class="o">(</span><span class="mf">4.</span><span class="n">second</span><span class="o">)</span> <span class="c1">// prints 2
</span><span class="nv">sc</span><span class="o">.</span><span class="py">tick</span><span class="o">(</span><span class="mf">4.</span><span class="n">second</span><span class="o">)</span> <span class="c1">// prints 3
</span></code></pre></div></div>

<h3 id="intervalatfixedrate">intervalAtFixedRate</h3>

<p><code class="highlighter-rouge">Observable.intervalAtFixedRate</code> is similar to <code class="highlighter-rouge">Observable.intervalWithFixedDelay</code> but the time it takes to
process an <code class="highlighter-rouge">onNext</code> event gets substracted from the specified <code class="highlighter-rouge">period</code> time. In other words, the created <code class="highlighter-rouge">Observable</code>
tries to emit events spaced by the given time interval, regardless of how long the processing of <code class="highlighter-rouge">onNext</code> takes.</p>

<p>The difference should be clearer after looking at the example below. 
Notice how it makes up for time spent in each <code class="highlighter-rouge">mapEval</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.schedulers.TestScheduler</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>

<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="c1">// using `TestScheduler` to manipulate time
</span><span class="k">implicit</span> <span class="k">val</span> <span class="nv">sc</span> <span class="k">=</span> <span class="nc">TestScheduler</span><span class="o">()</span>

<span class="k">val</span> <span class="nv">stream</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span>
    <span class="o">.</span><span class="py">intervalAtFixedRate</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span>
    <span class="o">.</span><span class="py">mapEval</span><span class="o">(</span><span class="n">l</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">l</span><span class="o">))</span>
    <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">stream</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">(</span><span class="n">sc</span><span class="o">)</span>

<span class="nv">sc</span><span class="o">.</span><span class="py">tick</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span> <span class="c1">// prints 0
</span><span class="nv">sc</span><span class="o">.</span><span class="py">tick</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span> <span class="c1">// prints 1
</span><span class="nv">sc</span><span class="o">.</span><span class="py">tick</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span> <span class="c1">// prints 2
</span><span class="nv">sc</span><span class="o">.</span><span class="py">tick</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span> <span class="c1">// prints 3
</span></code></pre></div></div>

<h2 id="error-handling">Error Handling</h2>

<p>Failing in any operator in <code class="highlighter-rouge">Observable</code> will lead to termination of the stream. It will inform downstream and upstream
about the failure, stopping entire <code class="highlighter-rouge">Observable</code> unless the error is handled.</p>

<p>Note that most errors should be handled at <code class="highlighter-rouge">Effect</code> level (e.g. <code class="highlighter-rouge">Task</code>, <code class="highlighter-rouge">IO</code> in <code class="highlighter-rouge">mapEval</code>), not by using <code class="highlighter-rouge">Observable</code> error handling operators. 
If <code class="highlighter-rouge">Observable</code> encounters an error it cannot ignore it and keep going. The best you can do without bigger machinery is to restart <code class="highlighter-rouge">Observable</code> or replace it with different one.</p>

<h3 id="handleerror-onerrorhandle">handleError (onErrorHandle)</h3>

<p><code class="highlighter-rouge">Observable.handleError</code> (alias for <code class="highlighter-rouge">onErrorHandle</code>) mirrors original source unless error happens - in which case it fallbacks to an <code class="highlighter-rouge">Observable</code> emitting one specified element generated by given total function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.reactive.Observable</span>

<span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">++</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">)</span> <span class="o">++</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="o">{</span>
<span class="n">observable</span>
  <span class="o">.</span><span class="py">onErrorHandle</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="mi">4</span><span class="o">)</span>
  <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">//=&gt; 1
//=&gt; 2
//=&gt; 3
//=&gt; 4
</span></code></pre></div></div>

<h3 id="handleerrorwith-onerrorhandlewith">handleErrorWith (onErrorHandleWith)</h3>

<p><code class="highlighter-rouge">Observable.handleErrorWith</code> (alias for <code class="highlighter-rouge">onErrorHandleWith</code>) mirrors original source unless error happens - in which case it fallbacks to an <code class="highlighter-rouge">Observable</code> generated by given total function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.reactive.Observable</span>

<span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">++</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">)</span> <span class="o">++</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="o">{</span>
<span class="n">observable</span>
  <span class="o">.</span><span class="py">onErrorHandleWith</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">))</span>
  <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">//=&gt; 1
//=&gt; 2
//=&gt; 3
//=&gt; 4
</span></code></pre></div></div>

<h3 id="recover-onerrorrecover">recover (onErrorRecover)</h3>

<p><code class="highlighter-rouge">Observable.recover</code> (alias for <code class="highlighter-rouge">onErrorRecover</code>) mirrors original source unless error happens - in which case it fallbacks to an <code class="highlighter-rouge">Observable</code> emitting one specified element generated by given partial function. The difference between <code class="highlighter-rouge">recover</code> and <code class="highlighter-rouge">handleError</code> is that the latter takes total function as a parameter.</p>

<h3 id="recoverwith-onerrorrecoverwith">recoverWith (onErrorRecoverWith)</h3>

<p><code class="highlighter-rouge">Observable.recoverWith</code> (alias for <code class="highlighter-rouge">onErrorRecoverWith</code>) mirrors original source unless error happens - in which case it fallbacks to an <code class="highlighter-rouge">Observable</code> generated by given partial function. The difference between <code class="highlighter-rouge">recoverWith</code> and <code class="highlighter-rouge">handleErrorWith</code> is that the latter takes total function as a parameter.</p>

<h3 id="onerrorfallbackto">onErrorFallbackTo</h3>

<p><code class="highlighter-rouge">Observable.onErrorFallbackTo</code> mirrors the behavior of the source, unless it is terminated with an <code class="highlighter-rouge">onError</code>, in which case the streaming of events continues with the specified backup sequence regardless of error.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.reactive.Observable</span>

<span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">++</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">)</span> <span class="o">++</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="o">{</span>
<span class="n">observable</span>
  <span class="o">.</span><span class="py">onErrorFallbackTo</span><span class="o">(</span><span class="nc">Observable</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">))</span>
  <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">//=&gt; 1
//=&gt; 2
//=&gt; 3
//=&gt; 4
</span></code></pre></div></div>

<p>This is equivalent to:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>
<span class="n">observable</span>
  <span class="o">.</span><span class="py">handleErrorWith</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="onerrorrestart">onErrorRestart</h3>

<p><code class="highlighter-rouge">Observable.onErrorRestart</code> mirrors the behavior of the source unless it is terminated with an <code class="highlighter-rouge">onError</code>, in which case it tries subscribing to the source again in the hope that it will complete without an error.</p>

<p>The number of retries is limited by the specified <code class="highlighter-rouge">maxRetries</code> parameter.</p>

<p>There is also <code class="highlighter-rouge">onErrorRestartUnlimited</code> variant for unlimited number of retries.</p>

<h3 id="onerrorrestartif">onErrorRestartIf</h3>

<p><code class="highlighter-rouge">Observable.onErrorRestartIf</code> mirrors the behavior of the source unless it is terminated with an <code class="highlighter-rouge">onError</code>, in which case it invokes provided function and tries subscribing to the source again in the hope that it will complete without an error.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.reactive.Observable</span>

<span class="k">case</span> <span class="k">object</span> <span class="nc">TimeoutException</span> <span class="k">extends</span> <span class="nc">Exception</span>

<span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">++</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="nc">TimeoutException</span><span class="o">)</span> <span class="o">++</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="o">{</span>
<span class="n">observable</span>
  <span class="o">.</span><span class="py">onErrorRestartIf</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">TimeoutException</span> <span class="k">=&gt;</span> <span class="kc">true</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
  <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">//=&gt; 1
//=&gt; 2
//=&gt; 3
//=&gt; 1
//=&gt; 2
//=&gt; 3
// ... fails and restarts infinitely
</span></code></pre></div></div>

<h3 id="retrying-with-delay">Retrying with delay</h3>

<p>Since <code class="highlighter-rouge">Observable</code> methods compose pretty nicely you could easily combine them to write custom retry mechanism:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">retryWithDelay</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">source</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">delay</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> 
  <span class="nv">source</span><span class="o">.</span><span class="py">onErrorHandleWith</span> <span class="o">{</span> <span class="k">_</span> <span class="k">=&gt;</span>
    <span class="nf">retryWithDelay</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">delay</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="n">delay</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Which can be customized further. For example, we can add exponential backoff:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">retryBackoff</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">source</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span>
  <span class="n">maxRetries</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">firstDelay</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">source</span><span class="o">.</span><span class="py">onErrorHandleWith</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">Exception</span> <span class="o">=&gt;</span>
      <span class="nf">if</span> <span class="o">(</span><span class="n">maxRetries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="nf">retryBackoff</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">maxRetries</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">firstDelay</span><span class="o">*</span><span class="mi">2</span><span class="o">)</span>
          <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="n">firstDelay</span><span class="o">)</span>
      <span class="k">else</span>
        <span class="nv">Observable</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="dropping-failed-elements">Dropping failed elements</h3>

<p>Sometimes we would like to ignore elements that caused failure and keep going but 
if something fails in <code class="highlighter-rouge">Observable</code> operator (e.g. mapEval) the entire <code class="highlighter-rouge">Observable</code> is failed with this error.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">task</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="nc">DummyException</span><span class="o">(</span><span class="s">"error"</span><span class="o">))</span>
  <span class="k">else</span> <span class="nc">Task</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="o">}</span>

<span class="o">{</span>
<span class="n">observable</span>
  <span class="o">.</span><span class="py">mapEval</span><span class="o">(</span><span class="n">task</span><span class="o">)</span>
  <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"elem: $e"</span><span class="o">))</span>
<span class="o">}</span>
<span class="c1">//=&gt; elem: 1
//=&gt; Exception in thread "main" monix.execution.exceptions.DummyException: error
</span></code></pre></div></div>

<p>There is nothing like supervision in Akka Streams but if we control it at the <code class="highlighter-rouge">Effect</code> level, we could achieve similar behavior.
For instance, we could wrap our elements in <code class="highlighter-rouge">Option</code> or <code class="highlighter-rouge">Either</code> and then do <code class="highlighter-rouge">collect { case Right(e) =&gt; e }</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">task</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="nc">DummyException</span><span class="o">(</span><span class="s">"error"</span><span class="o">))</span>
  <span class="k">else</span> <span class="nc">Task</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="o">}</span>

<span class="o">{</span>
<span class="n">observable</span>
  <span class="o">.</span><span class="py">mapEval</span><span class="o">(</span><span class="nf">task</span><span class="o">(</span><span class="k">_</span><span class="o">).</span><span class="py">attempt</span><span class="o">)</span> <span class="c1">// attempt transforms Task[A] into Task[Either[Throwable, A]] with all errors handled
</span>  <span class="o">.</span><span class="py">collect</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">evt</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">evt</span><span class="o">}</span>
  <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"elem: $e"</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">//=&gt; elem: 1
//=&gt; elem: 3
</span></code></pre></div></div>

<p>It’s not as nice as having one global Supervisor that handles it if something goes wrong but as long as you follow
basic rules such as not throwing exceptions and remembering that any <code class="highlighter-rouge">Task</code> can fail then you should be good to go.</p>

<h3 id="monaderror-instance">MonadError instance</h3>

<p><code class="highlighter-rouge">Observable</code> provides <code class="highlighter-rouge">MonadError[Observable, Throwable]</code> instance so you can use any <code class="highlighter-rouge">MonadError</code> operator for error handling.
If you are curious what it gives you in practice, check methods in <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/MonadError.scala">cats.MonadError</a> and <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/ApplicativeError.scala">cats.ApplicativeError</a>.</p>

<p>Many of these methods (and more) are defined directly on <code class="highlighter-rouge">Observable</code> and the rest can be acquired by calling <code class="highlighter-rouge">import cats.implicits._</code>.</p>

<h2 id="reacting-to-internal-events">Reacting to internal events</h2>

<p>If you remember, <code class="highlighter-rouge">Observable</code> internally calls <code class="highlighter-rouge">onNext</code> on every element, <code class="highlighter-rouge">onError</code> during error and <code class="highlighter-rouge">onComplete</code> after
stream completion. There are many many methods for executing given callback when the stream acquires specific type of event.
Usually they start with <code class="highlighter-rouge">doOn</code> or <code class="highlighter-rouge">doAfter</code>.</p>

<h3 id="doonnext">doOnNext</h3>

<p>Executes given callback for each element generated by the source <code class="highlighter-rouge">Observable</code>, useful for doing side-effects.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">counter</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="o">{</span>
<span class="n">observable</span>
  <span class="o">.</span><span class="py">doOnNext</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="n">counter</span> <span class="o">+=</span> <span class="n">e</span><span class="o">))</span>
  <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"elem: $e, counter: $counter"</span><span class="o">))</span>
<span class="o">}</span>
<span class="c1">//=&gt; elem: 1, counter: 1
//=&gt; elem: 2, counter: 3
//=&gt; elem: 3, counter: 6
</span></code></pre></div></div>

<p>You could also write it preserving referential transparency using <code class="highlighter-rouge">Ref</code> from <code class="highlighter-rouge">Cats-Effect</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.concurrent.Ref</span>
<span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>

<span class="k">def</span> <span class="nf">observable</span><span class="o">(</span><span class="n">counterRef</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">Task</span>, <span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="o">.</span><span class="py">doOnNext</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nv">counterRef</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="n">e</span><span class="o">))</span>
    <span class="o">.</span><span class="py">mapEval</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nv">counterRef</span><span class="o">.</span><span class="py">get</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">counter</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"elem: $e, counter: $counter"</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">completedL</span>
<span class="o">}</span>

<span class="nc">Ref</span><span class="o">[</span><span class="kt">Task</span><span class="o">].</span><span class="py">of</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="py">flatMap</span><span class="o">(</span><span class="n">observable</span><span class="o">)</span>
<span class="c1">// After executing:
//=&gt; elem: 1, counter: 1
//=&gt; elem: 2, counter: 3
//=&gt; elem: 3, counter: 6
</span></code></pre></div></div>

<p>There is also <code class="highlighter-rouge">doOnNextF</code> variant which works for data types other than <code class="highlighter-rouge">Task</code>.</p>

<h2 id="subjects">Subjects</h2>

<p><code class="highlighter-rouge">Subject</code> acts both as an <code class="highlighter-rouge">Observer</code> and as an <code class="highlighter-rouge">Observable</code>. Use <code class="highlighter-rouge">Subject</code> if you need to send elements to <code class="highlighter-rouge">Observable</code>
from other parts of the application.
It is presented in the following example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.Ack</span>
<span class="k">import</span> <span class="nn">monix.reactive.subjects.ConcurrentSubject</span>
<span class="k">import</span> <span class="nn">monix.reactive.</span><span class="o">{</span><span class="nc">MulticastStrategy</span><span class="o">,</span> <span class="nc">Observable</span><span class="o">,</span> <span class="nc">Observer</span><span class="o">}</span>

<span class="k">val</span> <span class="nv">subject</span><span class="k">:</span> <span class="kt">ConcurrentSubject</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">ConcurrentSubject</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nv">MulticastStrategy</span><span class="o">.</span><span class="py">replay</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">feedItem</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">observer</span><span class="k">:</span> <span class="kt">Observer</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">item</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Ack</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">deferFuture</span><span class="o">(</span><span class="nv">observer</span><span class="o">.</span><span class="py">onNext</span><span class="o">(</span><span class="n">item</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">processStream</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">observable</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">observable</span>
    <span class="o">.</span><span class="py">mapParallelUnordered</span><span class="o">(</span><span class="mi">3</span><span class="o">)(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">completedL</span>
<span class="o">}</span>

<span class="o">{</span>
<span class="nc">Task</span>
  <span class="o">.</span><span class="py">parZip2</span><span class="o">(</span>
    <span class="nf">feedItem</span><span class="o">(</span><span class="n">subject</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
    <span class="nf">processStream</span><span class="o">(</span><span class="n">subject</span><span class="o">)</span>
  <span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Subject</code> is also often used to specify multicast strategy in shared (hot) <code class="highlighter-rouge">Observable</code> to specify which elements are sent to
new subscribers. There are several strategies available and you can find their short characteristics below.</p>

<ul>
  <li><code class="highlighter-rouge">AsyncSubject</code> emits the last value (and only the last value) emitted by the source and only after the source completes.</li>
  <li><code class="highlighter-rouge">BehaviorSubject</code> emits the most recently emitted item by the source, or the <code class="highlighter-rouge">initialValue</code> in case no value has yet been emitted, then continue to emit events subsequent to the time of invocation.</li>
  <li><code class="highlighter-rouge">ConcurrentSubject</code> allows feeding events without the need to respect the back-pressure (waiting on <code class="highlighter-rouge">Ack</code> after <code class="highlighter-rouge">onNext</code>). It is similar to <a href="https://en.wikipedia.org/wiki/Actor_model">Actor</a> and can serve as its replacement in many cases.</li>
  <li><code class="highlighter-rouge">PublishSubject</code> emits to a subscriber only those items that are emitted by the source subsequent to the time of the subscription.</li>
  <li><code class="highlighter-rouge">PublishToOneSubject</code> is a <code class="highlighter-rouge">PublishSubject</code> that can be susbcribed at most once.</li>
  <li><code class="highlighter-rouge">ReplaySubject</code> emits to a subscriber all of the items that were emitted by the source, regardless of when the observer subscribes.</li>
  <li><code class="highlighter-rouge">Var</code> emits the most recently emmited item by the source, or the <code class="highlighter-rouge">initial</code> in case no value has yet been emitted, then continue to emit events subsequent to the time of invocation via an underlying <code class="highlighter-rouge">ConcurrentSubject</code>. This is equivalent to a <code class="highlighter-rouge">ConcurrentSubject.behavior(Unbounded)</code> with ability to expose the current value for immediate usage on top of that.</li>
</ul>

<p>For more information refer to descriptions and methods in <code class="highlighter-rouge">monix.reactive.subjects</code> package.</p>

<h2 id="sharing-observable">Sharing Observable</h2>

<p>As mentioned before - <code class="highlighter-rouge">Observable</code> doesn’t emit any items until something subscribes to it. 
If it can serve only one subscriber it is called <em>cold Observable.</em></p>

<p>On the other hand there is also a notion of <em>hot Observable</em> denoted as <code class="highlighter-rouge">ConnectableObservable</code> whose source can be shared between many subscribers.</p>

<h3 id="connectableobservable">ConnectableObservable</h3>

<p>Similarily to standard version, <code class="highlighter-rouge">ConnectableObservable</code> is lazy, i.e. it will start processing elements after
processing <code class="highlighter-rouge">connect()</code>. The crucial difference is that mapping <code class="highlighter-rouge">ConnectableObservable</code> returns <code class="highlighter-rouge">Observable</code> which
shares the source according to the specified strategy, represented by <code class="highlighter-rouge">Subject</code>.</p>

<p>Consider the following example which uses <code class="highlighter-rouge">.publish</code> to create a <code class="highlighter-rouge">ConnectableObservable</code> on top of a <code class="highlighter-rouge">PublishSubject</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.</span><span class="o">{</span><span class="nc">Cancelable</span><span class="o">,</span> <span class="nc">Scheduler</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>
<span class="k">import</span> <span class="nn">monix.reactive.observables.ConnectableObservable</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nv">Scheduler</span><span class="o">.</span><span class="py">global</span>

<span class="k">val</span> <span class="nv">source</span><span class="k">:</span> <span class="kt">ConnectableObservable</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">Observable</span><span class="o">.</span><span class="py">intervalAtFixedRate</span><span class="o">(</span><span class="mf">100.</span><span class="n">millis</span><span class="o">)</span>
    <span class="o">.</span><span class="py">doOnNext</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"source: $i"</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">publish</span>
<span class="o">}</span>

<span class="c1">// at this point source starts printing
</span><span class="k">val</span> <span class="nv">cancelable</span><span class="k">:</span> <span class="kt">Cancelable</span> <span class="o">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">connect</span><span class="o">()</span>

<span class="k">val</span> <span class="nv">o1</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="py">foreachL</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"o1: $i"</span><span class="o">)).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">200.</span><span class="n">millis</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">o2</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="py">foreachL</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"o2: $i"</span><span class="o">))</span>

<span class="nv">Task</span><span class="o">.</span><span class="py">parZip2</span><span class="o">(</span><span class="n">o1</span><span class="o">,</span> <span class="n">o2</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nv">cancelable</span><span class="o">.</span><span class="py">cancel</span><span class="o">())</span>
<span class="c1">// Sample Output after running:
// source: 0
// source: 1
// source: 2
// o2: 2
// source: 3
// o1: 3
// source: 4
// o1: 4
</span></code></pre></div></div>

<p>Calling <code class="highlighter-rouge">connect()</code> starts the streaming. In this case, it has managed to process 3 elements before <code class="highlighter-rouge">o2</code> subscribed 
so it didn’t receive all of them. It only took one element because of <code class="highlighter-rouge">take(1)</code>. If it was a normal <code class="highlighter-rouge">Observable</code> it would have been
canceled but that’s not the case with <code class="highlighter-rouge">ConnectableObservable</code>. Whenever each subscriber stops, it just unsubscribes. 
If it weren’t for <code class="highlighter-rouge">cancelable.cancel()</code> it would have keep going even after all subscribers stopped listening. Also note the
<code class="highlighter-rouge">source</code> was ran only once.</p>

<h3 id="backpressure">Backpressure</h3>

<p>Source <code class="highlighter-rouge">ConnectableObservable</code> is backpressured on <em>all</em> subscribers. In other words, it will wait for acknowledgement from
all active subscribers before processing the next element.</p>

<p>Let’s see it on an example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.</span><span class="o">{</span><span class="nc">Cancelable</span><span class="o">,</span> <span class="nc">Scheduler</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>
<span class="k">import</span> <span class="nn">monix.reactive.observables.ConnectableObservable</span>

<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nv">Scheduler</span><span class="o">.</span><span class="py">global</span>

<span class="k">val</span> <span class="nv">source</span><span class="k">:</span> <span class="kt">ConnectableObservable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span> <span class="c1">// delay to ensure subscribers will get all elements
</span>    <span class="o">.</span><span class="py">doOnNext</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"source: $i"</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">publish</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">cancelable</span><span class="k">:</span> <span class="kt">Cancelable</span> <span class="o">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">connect</span><span class="o">()</span>

<span class="k">val</span> <span class="nv">o1</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">delayOnNext</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">).</span><span class="py">foreachL</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"o1: $i"</span><span class="o">))</span>

<span class="k">val</span> <span class="nv">o2</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"o2: $i"</span><span class="o">))</span>

<span class="nv">Task</span><span class="o">.</span><span class="py">parZip2</span><span class="o">(</span><span class="n">o1</span><span class="o">,</span> <span class="n">o2</span><span class="o">)</span>
<span class="c1">// Sample Output after running:
// source: 1
// o2: 1
// -- 2 second delay -- 
// o1: 1
// source: 2
// o2: 2
// -- 2 second delay -- 
// o1: 2
// source: 3
// o2: 3
// -- 2 second delay -- 
// o1: 3
</span></code></pre></div></div>

<p>It might not be always desirable if we don’t want to slow down the producer. There are several ways to handle it, depending
on the use case. In general, if we don’t want backpressure, we need a buffer with proper overflow strategy.</p>

<p>For instance, we could introduce buffer per subscriber which can store up to 10 elements and then starts dropping new elements:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">subObservable</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">whileBusyBuffer</span><span class="o">(</span><span class="nv">OverflowStrategy</span><span class="o">.</span><span class="py">DropNew</span><span class="o">(</span><span class="mi">10</span><span class="o">))</span>
</code></pre></div></div>

<p>Or even disable backpressure completely with a function like <code class="highlighter-rouge">whileBusyDropEvents</code>.
From the perspective of <code class="highlighter-rouge">source</code>, the subscriber is always processing elements right away so it doesn’t have to wait on it.</p>

<h3 id="configuring-underlying-subject">Configuring underlying Subject</h3>

<p>For all plain <code class="highlighter-rouge">Subject</code>s, there are corresponding methods, i.e. <code class="highlighter-rouge">publish</code>, <code class="highlighter-rouge">publishLast</code>, <code class="highlighter-rouge">replay</code> etc. 
Different <code class="highlighter-rouge">Subjects</code> vary in behavior in regard to subscribers but <code class="highlighter-rouge">source</code> Observable will be always executed just once.</p>

<p>For instance, <code class="highlighter-rouge">ReplaySubject</code> will cache and send all elements to new subscribers:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nv">Scheduler</span><span class="o">.</span><span class="py">global</span>

<span class="k">val</span> <span class="nv">source</span><span class="k">:</span> <span class="kt">ConnectableObservable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="o">.</span><span class="py">doOnNext</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"source: $i"</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">replay</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">cancelable</span><span class="k">:</span> <span class="kt">Cancelable</span> <span class="o">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">connect</span><span class="o">()</span>

<span class="k">val</span> <span class="nv">o1</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"o1: $i"</span><span class="o">))</span>
<span class="c1">// Sample Output after running:
// source: 1
// source: 2
// source: 3
// o1: 1
// o1: 2
// o1: 3
</span></code></pre></div></div>

<p>Another example could be <code class="highlighter-rouge">BehaviorSubject</code> which remembers the latest element to feed to new subscribers:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nv">Scheduler</span><span class="o">.</span><span class="py">global</span>

<span class="k">val</span> <span class="nv">source</span><span class="k">:</span> <span class="kt">ConnectableObservable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="o">.</span><span class="py">doOnNext</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"source: $i"</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">behavior</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">cancelable</span><span class="k">:</span> <span class="kt">Cancelable</span> <span class="o">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">connect</span><span class="o">()</span>

<span class="k">val</span> <span class="nv">o1</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"o1: $i"</span><span class="o">))</span>
<span class="c1">// Sample Output after running:
// source: 1
// source: 2
// source: 3
// o1: 3
</span></code></pre></div></div>

<p>If it were <code class="highlighter-rouge">PublishSubject</code>, the subscriber would not receive any elements because the <code class="highlighter-rouge">source</code> has processed everything
before subscription.</p>

<h3 id="doing-it-the-pure-way">Doing it the pure way</h3>

<p>As you probably noticed, <code class="highlighter-rouge">ConnectableObservable</code> is not very pure because the time of subscription can completely change the result
and the original <code class="highlighter-rouge">source</code> is processed only once. Monix also exposes <code class="highlighter-rouge">publishSelector</code> and <code class="highlighter-rouge">pipeThroughSelector</code> which allow
to take advantage of Hot <code class="highlighter-rouge">Observable</code> in more controlled and purely functional fashion.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nv">Scheduler</span><span class="o">.</span><span class="py">global</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="o">{</span>  
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="o">.</span><span class="py">doOnNext</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Produced $i"</span><span class="o">))</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">consume</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">obs</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">obs</span><span class="o">.</span><span class="py">mapEval</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$name: got $i"</span><span class="o">)))</span>

<span class="k">val</span> <span class="nv">shared</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">source</span><span class="o">.</span><span class="py">publishSelector</span> <span class="o">{</span> <span class="n">hot</span> <span class="k">=&gt;</span>
    <span class="nc">Observable</span><span class="o">(</span>
      <span class="nf">consume</span><span class="o">(</span><span class="s">"Consumer 1"</span><span class="o">,</span> <span class="n">hot</span><span class="o">),</span>
      <span class="nf">consume</span><span class="o">(</span><span class="s">"Consumer 2"</span><span class="o">,</span> <span class="n">hot</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span>
    <span class="o">).</span><span class="py">merge</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="nv">shared</span><span class="o">.</span><span class="py">subscribe</span><span class="o">()</span>
<span class="nv">shared</span><span class="o">.</span><span class="py">subscribe</span><span class="o">()</span>
</code></pre></div></div>

<p>The code would print the following output twice:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Produced 1
Consumer 1: got 1
Produced 2
Consumer 1: got 2
Consumer 2: got 2
Produced 3
Consumer 1: got 3
Consumer 2: got 3
</code></pre></div></div>

<p><code class="highlighter-rouge">source</code> Observable is shared only in the scope of <code class="highlighter-rouge">publishSelector</code> and we can freely reuse its result and the original source.</p>

<p><code class="highlighter-rouge">publishSelector</code> uses <code class="highlighter-rouge">PublishSubject</code>. It is possible to customize it with <code class="highlighter-rouge">pipeThroughSelector</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">def</span> <span class="nf">pipeThroughSelector</span><span class="o">[</span><span class="kt">S</span> <span class="k">&gt;:</span> <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">R</span><span class="o">](</span><span class="n">pipe</span><span class="k">:</span> <span class="kt">Pipe</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Observable</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Pipe</code> has variants for all types of subjects, e.g. <code class="highlighter-rouge">source.pipeThroughSelector(Pipe.replay[Int], f)</code>.</p>

<h2 id="interoperability-with-other-streams-api-akka-streams-fs2">Interoperability with other Streams API (Akka Streams, FS2)</h2>

<p>Due to compability with the <a href="http://www.reactive-streams.org/">Reactive Streams</a>
specification <code class="highlighter-rouge">Observable</code> allows good interoperability with other libraries.</p>

<p>The next subsections contain examples how to convert between Monix <code class="highlighter-rouge">Observable</code> and
two other popular streaming libraries but it should work in similar way with every other library
compatible with Reactive Streams protocol.</p>

<h3 id="akka-streams">Akka Streams</h3>

<p>Necessary imports and initialization for <code class="highlighter-rouge">Akka Streams</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.reactive.Observable</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
<span class="k">import</span> <span class="nn">akka._</span>
<span class="k">import</span> <span class="nn">akka.stream._</span>
<span class="k">import</span> <span class="nn">akka.stream.scaladsl._</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">"akka-streams"</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">materializer</span> <span class="k">=</span> <span class="nc">ActorMaterializer</span><span class="o">()</span>
</code></pre></div></div>

<p>To convert Akka <code class="highlighter-rouge">Source</code> to Monix <code class="highlighter-rouge">Observable</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">3</span><span class="o">)</span>
<span class="c1">// source: akka.stream.scaladsl.Source[Int,akka.NotUsed] = Source(SourceShape(StatefulMapConcat.out(1887925338)))
</span>
<span class="k">val</span> <span class="nv">publisher</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">runWith</span><span class="o">(</span><span class="nv">Sink</span><span class="o">.</span><span class="py">asPublisher</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">fanout</span> <span class="k">=</span> <span class="kc">false</span><span class="o">))</span>
<span class="c1">// publisher: org.reactivestreams.Publisher[Int] = VirtualPublisher(state = Publisher[StatefulMapConcat.out(1887925338)])
</span>
<span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">fromReactivePublisher</span><span class="o">(</span><span class="n">publisher</span><span class="o">)</span>
<span class="c1">// observable: monix.reactive.Observable[Int] = monix.reactive.internal.builders.ReactiveObservable@72f8ecd
</span></code></pre></div></div>

<p>To go back from Monix <code class="highlighter-rouge">Observable</code> to Akka <code class="highlighter-rouge">Source</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="c1">// observable: monix.reactive.Observable[Int] = monix.reactive.internal.builders.IterableAsObservable@4783cc8
</span>
<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Source</span><span class="o">.</span><span class="py">fromPublisher</span><span class="o">(</span><span class="nv">observable</span><span class="o">.</span><span class="py">toReactivePublisher</span><span class="o">)</span>
<span class="c1">// source: akka.stream.scaladsl.Source[Int,akka.NotUsed] = Source(SourceShape(PublisherSource.out(989856637)))
</span></code></pre></div></div>

<h3 id="fs2">FS2</h3>

<p>To go between <a href="https://github.com/functional-streams-for-scala/fs2">FS2</a> Stream 
and Monix <code class="highlighter-rouge">Observable</code> you need to use <a href="https://github.com/zainab-ali/fs2-reactive-streams">fs2-reactive-streams</a>
library but conversion remains very straightforward.</p>

<p>Necessary imports:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect._</span><span class="o">,</span> <span class="nv">fs2</span><span class="o">.</span><span class="py">_</span>
<span class="k">import</span> <span class="nn">fs2.interop.reactivestreams._</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
</code></pre></div></div>

<p>To convert FS2 <code class="highlighter-rouge">Stream</code> to Monix <code class="highlighter-rouge">Observable</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="nc">Stream</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="py">covary</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span>
<span class="c1">// stream: fs2.Stream[cats.effect.IO,Int] = Stream(..)
</span>
<span class="k">val</span> <span class="nv">publisher</span> <span class="k">=</span> <span class="nv">stream</span><span class="o">.</span><span class="py">toUnicastPublisher</span><span class="o">()</span>
<span class="c1">// publisher: fs2.interop.reactivestreams.StreamUnicastPublisher[cats.effect.IO,Int] = fs2.interop.reactivestreams.StreamUnicastPublisher@6418f777
</span>
<span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">fromReactivePublisher</span><span class="o">(</span><span class="n">publisher</span><span class="o">)</span>
<span class="c1">// observable: monix.reactive.Observable[Int] = monix.reactive.internal.builders.ReactiveObservable@7130d725
</span></code></pre></div></div>

<p>To go back from Monix <code class="highlighter-rouge">Observable</code> to FS2 <code class="highlighter-rouge">Stream</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="c1">// observable: monix.reactive.Observable[Int] = monix.reactive.internal.builders.IterableAsObservable@4783cc8
</span>
<span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="nv">observable</span><span class="o">.</span><span class="py">toReactivePublisher</span><span class="o">.</span><span class="py">toStream</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span>
<span class="c1">// stream: fs2.Stream[cats.effect.IO,Int] = Stream(..)
</span></code></pre></div></div>


  <div id="version3x">
    You are viewing the documentation for the latest Monix 3.x series.<br/>
    If you're looking for the older 2.x
    <a href="/docs/2x/">click here</a>!
  </div>

  <div class="buttons">
    <a href="/docs/3x/">Contents</a> •
    <a href="https://github.com/monix/monix.io/edit/master/_tut/docs/3x/reactive/observable.md">
      Edit Page</a> •
    
    <a href="https://gitter.im/monix/monix">
      Join Chat</a> •
    <a href="/social.html">
      Follow</a>
  </div>
</div>

      </article>
    </div>
  </body>
</html>
